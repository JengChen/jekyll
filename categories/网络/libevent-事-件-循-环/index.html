<!DOCTYPE html>
<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   
   
   <title>libevent事件循环 - JengChen's WebSite</title>
   

   <meta name="author" content="JengChen" />
   
   <meta name="description" content="JengChen's WebSite libevent事件循环" />
   

   
  
   <link rel="icon" href=/images/index.png />

   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
   <link rel="stylesheet" href="/css/ionicons.css" type="text/css"/>

   <!-- Google Analytics Code -->
   <script type="text/javascript">

     var _gaq = _gaq || [];
     _gaq.push(['_setAccount', 'UA-38185696-1']);
     _gaq.push(['_trackPageview']);

     (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();

   </script>
   <!-- End Google Analytics Code -->

   <!-- Javascript needed by projects.html -->
   <script src="/javascripts/jquery.js" type="text/javascript" charset="utf-8"></script>
   <script type="text/javascript" src="/javascripts/jquery.github.js"></script>

   <!-- Google+ Plus One Button, asynchronous code -->
   <script type="text/javascript">
   (function() {
	var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
	po.src = 'https://apis.google.com/js/plusone.js';
	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>
<!-- End Google+ Plus One Button code -->
</head>

<body>
<div class="article-author-top">
	<img src="http://chenfjm.github.io/images/index.png" class="bio-photo" alt="JengChen bio photo" width="100" height="100"></a>
<h4>JengChen</h4>
<p></p>
<p style="text-indent:0; style="margin-top:1.5em;"><a href="mailto:chenfjm@gmail.com" target="_blank"><i class="icon-email"></i></a></p>
<p style="text-indent:0;"><a href="http://twitter.com/jengchen" target="_blank"><i class="icon-social-twitter"></i></a></p>
<p style="text-indent:0;"><a href="http://facebook.com/chenfjm" target="_blank"><i class="icon-social-facebook"></i></a></p>
<p style="text-indent:0;"><a href="http://google.com//chenfjm" target="_blank"><i class="icon-social-googleplus"></i></a></p>
<p style="text-indent:0;"><a href="http://linkedin.com/in/chenfjm" target="_blank"><i class="icon-social-linkedin"></i></a></p>
<p style="text-indent:0;"><a href="http://instagram.com/chenfjm" target="_blank"><i class="icon-social-instagram"></i></a></p>
<p style="text-indent:0;"><a href="http://github.com/chenfjm" target="_blank"><i class="icon-social-github"></i></a></p>


<p style="text-indent:0;"><a href="https://profile.yahoo.com/RGHZW2PYO5RVZLIOJ7MKDT5MDU/" target="_blank"><i class="icon-social-yahoo"></i></a></p>


</div>
<div class="site">
	<div class="title">
<a class="extra" href="/"><font size="6">Home</font></a> 
<a class="extra" href="/blog.html"><font size="6">blog</font></a>
<a class="extra" href="/projects.html"><font size="6">projects</font></a>
<a class="extra" href="/about.html"><font size="6">about</font></a>
</div>

	<h1>libevent事件循环</h1>
<p class="meta">23 Sep 2013</p>
<div class="social">
  <div class="share">
    <div class="g-plusone" data-size="medium"></div>
  </div>
  <div class="share">
    <iframe allowtransparency="true" frameborder="0" scrolling="no" src="http://platform.twitter.com/widgets/tweet_button.html?url=http://chenfjm.github.io/categories/%E7%BD%91%E7%BB%9C/libevent-%E4%BA%8B-%E4%BB%B6-%E5%BE%AA-%E7%8E%AF&text=libevent事件循环&hashtags=&via=JengChen&count=horizontal" style="width:115px; height:21px;"></iframe>
  </div>
</div>
<br />
<br />
<div id="post">
<p>libevent事件处理的中心部分——事件主循环，根据系统提供的事件多路分发机制执行事件循环，对已注册的就绪事件，调用注册事件的回调函数来处理事件。</p>

<p><strong>运行循环</strong></p>

<p>一旦有了一个已经注册了某些事件的event_base，就需要让libevent等待事件并且通知事件的发生。</p>

<pre><code>#define EVLOOP_ONCE             0x01
#define EVLOOP_NONBLOCK         0x02
#define EVLOOP_NO_EXIT_ON_EMPTY 0x04

int event_base_loop(struct event_base *base, int flags);  
</code></pre>

<p>默认情况下，event_base_loop（）函数运行直到event_base中没有已经注册的事件为止。执行循环的时候，函数重复地检查是否有任何已经注册的事件被触发（比如说，读事件的文件描述符已经就绪，可以读取了；或者超时事件的超时时间即将到达）。如果有事件被触发，函数标记被触发的事件为“激活的”，并且执行这些事件。 在flags参数中设置一个或者多个标志就可以改变event_base_loop（）的行为。如果设置了EVLOOP_ONCE，循环将等待某些事件成为激活的，执行激活的事件直到没有更多的事件可以执行，然会返回。如果设置了EVLOOP_NONBLOCK，循环不会等待事件被触发：循环将仅仅检测是否有事件已经就绪，可以立即触发，如果有，则执行事件的回调。完成工作后，如果正常退出，event_base_loop（）返回0；如果因为后端中的某些未处理错误而退出，则返回-1。</p>

<p>为方便起见，也可以调用</p>

<pre><code>int event_base_dispatch(struct event_base *base);  
</code></pre>

<p>event_base_dispatch（）等同于没有设置标志的event_base_loop（）。所以，event_base_dispatch（）将一直运行，直到没有已经注册的事件了，或者调用了event_base_loopbreak（）或者event_base_loopexit（）为止。</p>

<p><strong>停止循环</strong></p>

<p>如果想在移除所有已注册的事件之前停止活动的事件循环，可以调用两个稍有不同的函数。</p>

<pre><code>int event_base_loopexit(struct event_base *base,const struct timeval *tv);
int event_base_loopbreak(struct event_base *base);  
</code></pre>

<p>event_base_loopexit（）让event_base在给定时间之后停止循环。如果tv参数为NULL，event_base会立即停止循环，没有延时。如果event_base当前正在执行任何激活事件的回调，则回调会继续运行，直到运行完所有激活事件的回调之才退出。event_base_loopbreak（）让event_base立即退出循环。它与event_base_loopexit（base,NULL）的不同在于，如果event_base当前正在执行激活事件的回调，它将在执行完当前正在处理的事件后立即退出。</p>

<p>有时候需要知道对event_base_dispatch（）或者event_base_loop（）的调用是正常退出的，还是因为调用event_base_loopexit（）或者event_base_break（）而退出的。可以调用下述函数来确定是否调用了loopexit或者break函数。</p>

<pre><code>int event_base_got_exit(struct event_base *base);
int event_base_got_break(struct event_base *base);  
</code></pre>

<p>这两个函数分别会在循环是因为调用event_base_loopexit（）或者event_base_break（）而退出的时候返回true，否则返回false。下次启动事件循环的时候，这些值会被重设。</p>

<p><strong>集成Timer事件</strong></p>

<p>libevent将Timer和Signal事件都统一到了系统的I/O的demultiplex机制中了。首先将Timer事件融合到系统I/O多路复用机制中，还是相当清晰的，因为系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I/O事件发生，它们也保证能在timeout时间内返回。那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。这是在Reactor和Proactor模式中处理Timer事件的经典方法了，ACE采用的也是这种方法。堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)；因此变成了管理Timer事件的绝佳人选，libevent就是采用堆结构。</p>

<p><strong>集成Signal事件</strong></p>

<p>Signal是异步事件的经典事例，将Signal事件统一到系统的I/O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核在此信号发生时，请执行相应的操作”。如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理，就可以了。这就是libevent中使用的方法。libevent是通过socket pair来通知系统的I/O机制。</p>

<p>libevent中Signal事件的管理是通过结构体evsignal_info完成的，结构体位于evsignal.h文件中，定义如下：</p>

<pre><code>struct evsignal_info {  
struct event ev_signal;  
int ev_signal_pair[2];  
int ev_signal_added;  
volatile sig_atomic_t evsignal_caught;  
struct event_list evsigevents[NSIG];  
sig_atomic_t evsigcaught[NSIG];  
#ifdef HAVE_SIGACTION  
struct sigaction **sh_old;  
#else  
ev_sighandler_t **sh_old;  
#endif  
int sh_old_max;  
};  
</code></pre>

<p>下面详细介绍一下个字段的含义和作用：</p>

<ul>
<li>ev_signal， 为socket pair的读socket向event_base注册读事件时使用的event结构体；</li>
<li>ev_signal_pair，socket pair对；</li>
<li>ev_signal_added，记录ev_signal事件是否已经注册了；</li>
<li>evsignal_caught，是否有信号发生的标记；是volatile类型，因为它会在另外的线程中被修改；</li>
<li>evsigvents[NSIG]，数组，evsigevents[signo]表示注册到信号signo的事件链表；</li>
<li>evsigcaught[NSIG]，具体记录每个信号触发的次数，evsigcaught[signo]是记录信号signo被触发的次数；</li>
<li>sh_old记录了原来的signal处理函数指针，当信号signo注册的event被清空时，需要重新设置其处理函数；</li>
</ul>


<p>evsignal_info的初始化包括，创建socket pair，设置ev_signal事件（但并没有注册，而是等到有信号注册时才检查并注册），并将所有标记置零，初始化信号的注册事件链表指针等。</p>

</div>
  <wb:share-button type="button" size="middle" relateuid="2418291384" ></wb:share-button>
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jengchen'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

	  <div class="footer">
        <div class="rss">
        <p>
        <!-- AddThis Button BEGIN -->
         <div class="addthis_toolbox addthis_default_style ">
         <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
         <a class="addthis_button_tweet"></a>
         <div class="g-plusone" data-size="medium" data-annotation="none" data-href="http:chencheng.sn.cn//"></div>
         </div>
         <script type="text/javascript">var addthis_config = {"data_track_addressbar":true};</script>
         <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-510e74d2791fd39c"></script>
         </p>
         </div>
  </div>

</div>
</body>
</html>

