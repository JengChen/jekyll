<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<title>libevent核心 - event - ChenCheng's WebSite</title>


<meta name="author" content="ChenCheng" />

<meta name="description" content="ChenCheng's WebSite libevent核心 - event" />




<link rel="icon" href=/images/index.png />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen, projection" />
<link rel="stylesheet" href="/css/prettify.css" type="text/css" media="screen, projection">
<link rel="stylesheet" href="/css/ionicons.css" >
<link rel="stylesheet" href="/css/lifestream.css" >

<script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.min.js" charset="utf-8"></script>
<script type="text/javascript" src="/javascripts/jquery.github.js"></script>
<script type="text/javascript" src="/javascripts/prettify.js"></script>
<script src="/javascripts/jquery.lifestream.min.js"></script>
</head>

<body>
<div class="bar">
	<img src="http://chenfjm.github.io/images/me.jpg" class="bio-photo" alt=" bio photo" width="100" height="100"></a>
<h4></h4>
<p></p>
<p style="text-indent:0;margin-top:1.5em;"><a href="mailto:chenfjm@gmail.com" target="_blank"><i class="icon-email"></i></a></p>
<p style="text-indent:0;"><a href="http://twitter.com/chenfjm" target="_blank"><i class="icon-social-twitter"></i></a></p>
<p style="text-indent:0;"><a href="http://facebook.com/chenfjm" target="_blank"><i class="icon-social-facebook"></i></a></p>
<p style="text-indent:0;"><a href="https://plus.google.com/u/0/104464021526429289930" target="_blank"><i class="icon-social-googleplus"></i></a></p>
<p style="text-indent:0;"><a href="http://linkedin.com/in/chenfjm" target="_blank"><i class="icon-social-linkedin"></i></a></p>
<p style="text-indent:0;"><a href="http://instagram.com/chenfjm" target="_blank"><i class="icon-social-instagram"></i></a></p>
<p style="text-indent:0;"><a href="http://github.com/chenfjm" target="_blank"><i class="icon-social-github"></i></a></p>

<p style="text-indent:0;"><a href="https://profile.yahoo.com/RGHZW2PYO5RVZLIOJ7MKDT5MDU/" target="_blank"><i class="icon-social-yahoo"></i></a></p>

	</br>
	<h4>category</h4>
<ul>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/其他" title="view all
posts">其他 (4)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/cpp" title="view all
posts">cpp (2)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/网络" title="view all
posts">网络 (6)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/工具" title="view all
posts">工具 (1)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/linux" title="view all
posts">linux (2)</a>
</p>

</ul>

</div>
<div class="site">
	<div class="title">
<a class="extra" href="/">
<font size="6">
Home</font></a> <a class="extra" href="/blog.html"><font size="6">blog</font></a>
<a class="extra" href="/projects.html"><font size="6">projects</font></a>
<a class="extra" href="/about.html"><font size="6">about</font></a>
</div>

	<h1>libevent核心 - event</h1>
<p class="meta">15 Sep 2013</p>
<div id="post">
<p><strong>event结构体</strong></p>




<p>Libevent是基于事件驱动（event-driven）的，从名字也可以看到event是整个库的核心。event就是Reactor框架中的事件处理程序组件；它提供了函数接口，供Reactor在事件发生时调用，以执行相应的事件处理，通常它会绑定一个有效的句柄。<br/>
首先给出event结构体的定义，它位于event_struct.h文件中：</p>




<pre><code>struct event {
struct event_callback ev_evcallback;

/* for managing timeouts */
union {
    TAILQ_ENTRY(event) ev_next_with_common_timeout;
    int min_heap_idx;
} ev_timeout_pos;
evutil_socket_t ev_fd;

struct event_base *ev_base;

union {
    /* used for io events */
    struct {
        LIST_ENTRY (event) ev_io_next;
        struct timeval ev_timeout;
    } ev_io;

    /* used by signal events */
    struct {
        LIST_ENTRY (event) ev_signal_next;
        short ev_ncalls;
        /* Allows deletes in callback */
        short *ev_pncalls;
    } ev_signal;
} ev_;

short ev_events;
short ev_res;       /* result passed to event callback */
struct timeval ev_timeout;
};  
</code></pre>




<p>下面简单解释一下结构体中各字段的含义。</p>




<ul>
<li>ev_evcallback:event的回调函数，被ev_base调用，执行事件处理程序。</li>
<li>ev_timeout_pos:管理定时事件。</li>
<li>ev_base:该事件所属的反应堆实例，这是一个event_base结构体。</li>
<li>ev_:这是一个联合，里面包含两个结构体，ev_io和ev_signal。ev_io是该IO事件在IO事件列表中的位置，ev_signal是该signal事件在signal事件列表中的位置。信号和IO事件不能同时设置，因此它们在一个union中。</li>
<li>ev_events：event关注的事件类型，它可以是以下3种类型：

<ul>
<li>I/O事件： EV_WRITE和EV_READ</li>
<li>定时事件：EV_TIMEOUT</li>
<li>信号：    EV_SIGNAL</li>
<li>辅助选项：EV_PERSIST，表明是一个永久事件。</li>
</ul>
</li>
<li>ev_res：记录了当前激活事件的类型。</li>
<li>ev_timeout: 如果是超时事件，它是event的超时值。</li>
</ul>




<p><strong>创建事件</strong></p>




<p>使用event_new（）接口创建事件。</p>




<pre><code>#define EV_TIMEOUT      0x01   
#define EV_READ         0x02  
#define EV_WRITE        0x04  
#define EV_SIGNAL       0x08  
#define EV_PERSIST      0x10  
#define EV_ET           0x20  
typedef void (*event_callback_fn)(evutil_socket_t, short, void *);  
struct event *event_new(struct event_base *base, evutil_socket_t fd,short what, event_callback_fn cb,void *arg);  
void event_free(struct event *event);  
</code></pre>




<p>event_new()试图分配和构造一个用于base的新的事件。what参数是上述标志的集合。如果fd非负，则它是将被观察其读写事件的文件。事件被激活时，libevent将调用cb函数，传递这些参数：文件描述符fd，表示所有被触发事件的位字段，以及构造事件时的arg参数。发生内部错误，或者传入无效参数时，event_new（）将返回NULL。</p>




<p><strong>事件标志</strong></p>




<ul>
<li>EV_TIMEOUT:这个标志表示某超时时间流逝后事件成为激活的。构造事件的时候，EV_TIMEOUT标志是被忽略的：可以在添加事件的时候设置超时，也可以不设置。超时发生时，回调函数的what参数将带有这个标志。</li>
<li>EV_READ:表示指定的文件描述符已经就绪，可以读取的时候，事件将成为激活的。</li>
<li>EV_WRITE:表示指定的文件描述符已经就绪，可以写入的时候，事件将成为激活的。</li>
<li>EV_SIGNAL:用于实现信号检测。</li>
<li>EV_PERSIST:表示事件是“持久的”。</li>
<li>EV_ET:表示如果底层的event_base后端支持边沿触发事件，则事件应该是边沿触发的。这个标志影响EV_READ和EV_WRITE的语义。</li>
</ul>




<p><strong>添加事件</strong></p>




<p>构造事件之后，在将其添加到event_base之前实际上是不能对其做任何操作的。使用event_add（）将事件添加到event_base。</p>




<pre><code>int event_add(struct event *ev, const struct timeval *tv); 
</code></pre>




<p>在非未决的事件上调用event_add（）将使其在配置的event_base中成为未决的。成功时函数返回0，失败时返回-1。如果tv为NULL，添加的事件不会超时。否则，tv以秒和微秒指定超时值。如果对已经未决的事件调用event_add（），事件将保持未决状态，并在指定的超时时间被重新调度。</p>




<p>对已经初始化的事件调用event_del（）将使其成为非未决和非激活的。如果事件不是未决的或者激活的，调用将没有效果。成功时函数返回0，失败时返回-1。</p>




<pre><code>int event_del(struct event *ev);  
</code></pre>




<p><strong>设置优先级</strong></p>




<p>多个事件同时触发时，libevent没有定义各个回调的执行次序。可以使用优先级来定义某些事件比其他事件更重要。每个event_base有与之相关的一个或者多个优先级。在初始化事件之后，但是在添加到event_base之前，可以为其设置优先级。事件的优先级是一个在0和event_base的优先级减去1之间的数值。成功时函数返回0，失败时返回-1。多个不同优先级的事件同时成为激活的时候，低优先级的事件不会运行。libevent会执行高优先级的事件，然后重新检查各个事件。只有在没有高优先级的事件是激活的时候，低优先级的事件才会运行。</p>




<pre><code>int event_priority_set(struct event *event, int priority);  
</code></pre>




<p><strong>检查事件状态</strong></p>




<pre><code>int event_pending(const struct event *ev, short what, struct timeval *tv_out);
#define event_get_signal(ev) /* ... */
evutil_socket_t event_get_fd(const struct event *ev);
struct event_base *event_get_base(const struct event *ev);
short event_get_events(const struct event *ev);
event_callback_fn event_get_callback(const struct event *ev);
void *event_get_callback_arg(const struct event *ev);
int event_get_priority(const struct event *ev);

void event_get_assignment(const struct event *event,
    struct event_base **base_out,
    evutil_socket_t *fd_out,
    short *events_out,
    event_callback_fn *callback_out,
    void **arg_out);  
</code></pre>




<p>event_pending（）函数确定给定的事件是否是未决的或者激活的。如果是，而且what参数设置了EV_READ、EV_WRITE、EV_SIGNAL或者EV_TIMEOUT等标志，则函数会返回事件当前为之未决或者激活的所有标志。如果提供了tv_out参数，并且what参数中设置了EV_TIMEOUT标志，而事件当前正因超时事件而未决或者激活，则tv_out会返回事件的超时值。event_get_fd（）和event_get_signal（）返回为事件配置的文件描述符或者信号值。event_get_base（）返回为事件配置的event_base。event_get_events（）返回事件的标志（EV_READ、EV_WRITE等）。event_get_callback（）和event_get_callback_arg（）返回事件的回调函数及其参数指针。 event_get_assignment（）复制所有为事件分配的字段到提供的指针中。任何为NULL的参数会被忽略。</p>




<p><strong>配置一次触发事件</strong></p>




<p>如果不需要多次添加一个事件，或者要在添加后立即删除事件，而事件又不需要是持久的，则可以使用event_base_once（）。</p>




<pre><code>int event_base_once(struct event_base *, evutil_socket_t, short,
void (*)(evutil_socket_t, short, void *), v     oid *, const struct timeval *);  
</code></pre>




<p>除了不支持EV_SIGNAL或者EV_PERSIST之外，这个函数的接口与event_new（）相同。安排的事件将以默认的优先级加入到event_base并执行。回调被执行后，libevent内部将会释放event结构。成功时函数返回0，失败时返回-1。不能删除或者手动激活使用event_base_once（）插入的事件：如果希望能够取消事件，应该使用event_new（）或者event_assign（）。</p>




<p><strong>手动激活事件</strong></p>




<p>极少数情况下，需要在事件的条件没有触发的时候让事件成为激活的。</p>




<pre><code>void event_active(struct event *ev, int what, short ncalls);  
</code></pre>




<p>这个函数让事件ev带有标志what（EV_READ、EV_WRITE和EV_TIMEOUT的组合）成为激活的。事件不需要已经处于未决状态，激活事件也不会让它成为未决的。</p>


<!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1393946814461884" charset="utf-8"></script>
<!-- JiaThis Button END -->
</div>
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jengchen'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    $(document).ready(function() {
		$('pre').addClass('prettyprint').attr('style', 'overflow:auto');
        prettyPrint();
    });
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

</div>
	<div class="footer">
<div class=contact>
<p>©2014 Email:chenfjm@gmail.com Tel:18520222024 </p>
</div>
<div class="share">
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
<a class="addthis_button_tweet"></a>
<div class="g-plusone" data-size="medium" data-annotation="none" data-href="http:chencheng.sn.cn//"></div>
</div>
<script type="text/javascript">var addthis_config = {"data_track_addressbar":true};</script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-510e74d2791fd39c"></script>

<!-- Google+ Plus One Button, asynchronous code -->
<script type="text/javascript">
(function() {
 var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
 po.src = 'https://apis.google.com/js/plusone.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
 })();
</script>
<!-- End Google+ Plus One Button code -->
</div>
</div>

</body>
</html>

