<!DOCTYPE html>
<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   
   
   <title>libevent事件处理框架－event_base - JengChen's WebSite</title>
   

   <meta name="author" content="JengChen" />
   
   <meta name="description" content="JengChen's WebSite libevent事件处理框架－event_base" />
   

   
  
   <link rel="icon" href=/images/index.png />
   <link rel="stylesheet" href="/css/main.css" type="text/css" media="screen, projection" />
   <link rel="stylesheet" href="/css/prettify.css" type="text/css" media="screen, projection">
   <link rel="stylesheet" href="/css/ionicons.css" >

   <script src="/javascripts/jquery.js" type="text/javascript" charset="utf-8"></script>
   <script type="text/javascript" src="/javascripts/jquery.github.js"></script>
   <script type="text/javascript" src="/javascripts/prettify.js"></script>

</head>

<body>
<div class="bar">
	<img src="http://chenfjm.github.io/images/index.png" class="bio-photo" alt="JengChen bio photo" width="100" height="100"></a>
<h4>JengChen</h4>
<p></p>
<p style="text-indent:0;margin-top:1.5em;"><a href="mailto:chenfjm@gmail.com" target="_blank"><i class="icon-email"></i></a></p>
<p style="text-indent:0;"><a href="http://twitter.com/jengchen" target="_blank"><i class="icon-social-twitter"></i></a></p>
<p style="text-indent:0;"><a href="http://facebook.com/chenfjm" target="_blank"><i class="icon-social-facebook"></i></a></p>
<p style="text-indent:0;"><a href="http://google.com//chenfjm" target="_blank"><i class="icon-social-googleplus"></i></a></p>
<p style="text-indent:0;"><a href="http://linkedin.com/in/chenfjm" target="_blank"><i class="icon-social-linkedin"></i></a></p>
<p style="text-indent:0;"><a href="http://instagram.com/chenfjm" target="_blank"><i class="icon-social-instagram"></i></a></p>
<p style="text-indent:0;"><a href="http://github.com/chenfjm" target="_blank"><i class="icon-social-github"></i></a></p>

<p style="text-indent:0;"><a href="https://profile.yahoo.com/RGHZW2PYO5RVZLIOJ7MKDT5MDU/" target="_blank"><i class="icon-social-yahoo"></i></a></p>

	</br>
	<h4>category</h4>
<ul>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/其他" title="view all
posts">其他 (3)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/cpp" title="view all
posts">cpp (2)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/网络" title="view all
posts">网络 (6)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/unix" title="view all
posts">unix (1)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/工具" title="view all
posts">工具 (1)</a>
</p>

</ul>

</div>
<div class="site">
	<div class="title">
<a class="extra" href="/">
<font size="6">
Home</font></a> <a class="extra" href="/blog.html"><font size="6">blog</font></a>
<a class="extra" href="/projects.html"><font size="6">projects</font></a>
<a class="extra" href="/about.html"><font size="6">about</font></a>
</div>

	<h1>libevent事件处理框架－event_base</h1>
<p class="meta">20 Sep 2013</p>
<div id="post">
<p><strong>event_base结构体</strong></p>

<p>在libevent中event_base就是Reactor的框架组件，event_base结构体定义如下，它位于event-internal.h文件中。</p>

<pre><code>struct event_base {
const struct eventop *evsel;
void *evbase;
struct event_changelist changelist;
const struct eventop *evsigsel;
struct evsig_info sig;
int virtual_event_count;
int virtual_event_count_max;
int event_count;
int event_count_max;
int event_count_active;
int event_count_active_max;
int event_gotterm;
int event_break;
int event_continue;
int event_running_priority;
int running_loop;
int n_deferreds_queued;
struct evcallback_list *activequeues;
int nactivequeues;
struct evcallback_list active_later_queue;
struct common_timeout_list **common_timeout_queues;
int n_common_timeouts;
int n_common_timeouts_allocated;
struct event_io_map io;
struct event_signal_map sigmap;
struct min_heap timeheap;
struct timeval tv_cache;
struct evutil_monotonic_timer monotonic_timer;
struct timeval tv_clock_diff;
time_t last_updated_clock_diff;
#ifndef EVENT__DISABLE_THREAD_SUPPORT
unsigned long th_owner_id;
void *th_base_lock;
void *current_event_cond;
int current_event_waiters;
#endif
struct event_callback *current_event;
#ifdef _WIN32
struct event_iocp_port *iocp;
#endif
enum event_base_config_flag flags;
struct timeval max_dispatch_time;
int max_dispatch_callbacks;
int limit_callbacks_after_prio;
int is_notify_pending;
evutil_socket_t th_notify_fd[2];
struct event th_notify;
int (*th_notify_fn)(struct event_base *base);
struct evutil_weakrand_state weakrand_seed;
LIST_HEAD(once_event_list, event_once) once_events;
};  
</code></pre>

<p><strong>创建event_base</strong></p>

<p>使用libevent函数之前需要分配一个或者多个event_base结构体。每个event_base结构体持有一个事件集合，可以检测以确定哪个事件是激活的。如果设置event_base使用锁，则可以安全地在多个线程中访问它。然而，其事件循环只能运行在一个线程中。如果需要用多个线程检测IO，则需要为每个线程使用一个event_base。每个event_base都有一种用于检测哪种事件已经就绪的“方法”，或者说后端。可以识别的方法有：</p>

<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
<li>devpoll</li>
<li>evport</li>
<li>win32</li>
</ul>


<p>用户可以用环境变量禁止某些特定的后端。比如说，要禁止kqueue后端，可以设置EVENT_NOKQUEUE环境变量。如果要用编程的方法禁止后端，请看下面关于event_config_avoid_method（）的说明。<br/>
event_base_new（）函数分配并且返回一个新的具有默认设置的event_base。函数会检测环境变量，返回一个到event_base的指针。如果发生错误，则返回NULL。选择各种方法时，函数会选择OS支持的最快方法。</p>

<pre><code>struct event_base *event_base_new(void);  
</code></pre>

<p>要对取得什么类型的event_base有更多的控制，就需要使用event_config。event_config是一个容纳event_base配置信息的不透明结构体。需要event_base时，将event_config传递给event_base_new_with_config（）。</p>

<pre><code>struct event_config *event_config_new(void);
struct event_base *event_base_new_with_config(const struct event_config *cfg);
void event_config_free(struct event_config *cfg);  
</code></pre>

<p>要使用这些函数分配event_base，先调用event_config_new（）分配一个event_config。然后，对event_config调用其它函数，设置所需要的event_base特征。最后，调用event_base_new_with_config（）获取新的event_base。完成工作后，使用event_config_free（）释放event_config。</p>

<p><strong>后端设置</strong></p>

<pre><code>int event_config_avoid_method(struct event_config *cfg, const char *method);
enum event_method_feature {
    EV_FEATURE_ET = 0x01,
    EV_FEATURE_O1 = 0x02,
    EV_FEATURE_FDS = 0x04,
};
int event_config_require_features(struct event_config *cfg,
                              enum event_method_feature feature);

enum event_base_config_flag {
    EVENT_BASE_FLAG_NOLOCK = 0x01,
    EVENT_BASE_FLAG_IGNORE_ENV = 0x02,
    EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,
    EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,
    EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,
    EVENT_BASE_FLAG_PRECISE_TIMER = 0x20
};
int event_config_set_flag(struct event_config *cfg,
    enum event_base_config_flag flag);  
</code></pre>

<p>调用event_config_avoid_method（）可以通过名字让libevent避免使用特定的可用后端。调用event_config_require_feature（）让libevent不使用不能提供所有指定特征的后端。调用event_config_set_flag（）让libevent在创建event_base时设置一个或者多个将在下面介绍的运行时标志。</p>

<p>event_config_require_features（）可识别的特征值有：</p>

<ul>
<li>EV_FEATURE_ET：要求支持边沿触发的后端</li>
<li>EV_FEATURE_O1：要求添加、删除单个事件，或者确定哪个事件激活的操作是O（1）复杂度的后端</li>
<li>EV_FEATURE_FDS：要求支持任意文件描述符，而不仅仅是套接字的后端</li>
</ul>


<p>event_config_set_flag（）可识别的选项值有：</p>

<ul>
<li>EVENT_BASE_FLAG_NOLOCK：不要为event_base分配锁。设置这个选项可以为event_base节省一点用于锁定和解锁的时间，但是让在多个线程中访问event_base成为不安全的。</li>
<li>EVENT_BASE_FLAG_IGNORE_ENV：选择使用的后端时，不要检测EVENT_*环境变量。使用这个标志需要三思：这会让用户更难调试你的程序与libevent的交互。</li>
<li>EVENT_BASE_FLAG_STARTUP_IOCP：仅用于Windows，让libevent在启动时就启用任何必需的IOCP分发逻辑，而不是按需启用。</li>
<li>EVENT_BASE_FLAG_NO_CACHE_TIME：不是在事件循环每次准备执行超时回调时检测当前时间，而是在每次超时回调后进行检测。注意：这会消耗更多的CPU时间。</li>
<li>EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST：告诉libevent，如果决定使用epoll后端，可以安全地使用更快的基于changelist的后端。epoll-changelist后端可以在后端的分发函数调用之间，同样的fd多次修改其状态的情况下，避免不必要的系统调用。但是如果传递任何使用dup（）或者其变体克隆的fd给libevent，epoll-changelist后端会触发一个内核bug，导致不正确的结果。在不使用epoll后端的情况下，这个标志是没有效果的。也可以通过设置EVENT_EPOLL_USE_CHANGELIST环境变量来打开epoll-changelist选项。</li>
</ul>


<p>上述操作event_config的函数都在成功时返回0，失败时返回-1</p>

<p><strong>释放event_base</strong></p>

<p>使用完event_base之后，使用event_base_free（）进行释放。</p>

<pre><code>void event_base_free(struct event_base *base);  
</code></pre>

<p>注意：这个函数不会释放当前与event_base关联的任何事件，或者关闭他们的套接字，或者释放任何指针。</p>

<p><strong>设置event_base的优先级</strong></p>

<p>libevent支持为事件设置多个优先级。然而，event_base默认只支持单个优先级。可以调用event_base_priority_init（）设置event_base的优先级数目。</p>

<pre><code>int event_base_priority_init(struct event_base *base, int n_priorities);  
</code></pre>

<p>成功时这个函数返回0，失败时返回-1。base是要修改的event_base，n_priorities是要支持的优先级数目，这个数目至少是1。每个新的事件可用的优先级将从0（最高）到n_priorities-1（最低）。常量EVENT_MAX_PRIORITIES表示n_priorities的上限。调用这个函数时为n_priorities给出更大的值是错误的。</p>

</div>
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jengchen'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    $(document).ready(function() {
		$('pre').addClass('prettyprint').attr('style', 'overflow:auto');
        prettyPrint();
    });
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

	<div class="footer">
<div class="rss">
<p>
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
<a class="addthis_button_tweet"></a>
<div class="g-plusone" data-size="medium" data-annotation="none" data-href="http:chencheng.sn.cn//"></div>
</div>
<script type="text/javascript">var addthis_config = {"data_track_addressbar":true};</script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-510e74d2791fd39c"></script>

<!-- Google+ Plus One Button, asynchronous code -->
<script type="text/javascript">
(function() {
 var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
 po.src = 'https://apis.google.com/js/plusone.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
 })();
</script>
<!-- End Google+ Plus One Button code -->
</p>
</div>
</div>

</div>
</body>
</html>

