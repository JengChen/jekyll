<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />


<title>使用coroutine进行异步编程 - ChenCheng's WebSite</title>


<meta name="author" content="ChenCheng" />

<meta name="description" content="ChenCheng's WebSite 使用coroutine进行异步编程" />




<link rel="icon" href=/images/index.png />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen, projection" />
<link rel="stylesheet" href="/css/prettify.css" type="text/css" media="screen, projection">
<link rel="stylesheet" href="/css/ionicons.css" >
<link rel="stylesheet" href="/css/lifestream.css" >

<script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.min.js" charset="utf-8"></script>
<script type="text/javascript" src="/javascripts/jquery.github.js"></script>
<script type="text/javascript" src="/javascripts/prettify.js"></script>
<script src="/javascripts/jquery.lifestream.min.js"></script>
</head>

<body>
<div class="bar">
	<img src="http://chenfjm.github.io/images/me.jpg" class="bio-photo" alt=" bio photo" width="100" height="100"></a>
<h4></h4>
<p></p>
<p style="text-indent:0;margin-top:1.5em;"><a href="mailto:chenfjm@gmail.com" target="_blank"><i class="icon-email"></i></a></p>
<p style="text-indent:0;"><a href="http://twitter.com/chenfjm" target="_blank"><i class="icon-social-twitter"></i></a></p>
<p style="text-indent:0;"><a href="http://facebook.com/chenfjm" target="_blank"><i class="icon-social-facebook"></i></a></p>
<p style="text-indent:0;"><a href="https://plus.google.com/u/0/104464021526429289930" target="_blank"><i class="icon-social-googleplus"></i></a></p>
<p style="text-indent:0;"><a href="http://linkedin.com/in/chenfjm" target="_blank"><i class="icon-social-linkedin"></i></a></p>
<p style="text-indent:0;"><a href="http://instagram.com/chenfjm" target="_blank"><i class="icon-social-instagram"></i></a></p>
<p style="text-indent:0;"><a href="http://github.com/chenfjm" target="_blank"><i class="icon-social-github"></i></a></p>

<p style="text-indent:0;"><a href="https://profile.yahoo.com/RGHZW2PYO5RVZLIOJ7MKDT5MDU/" target="_blank"><i class="icon-social-yahoo"></i></a></p>

	</br>
	<h4>category</h4>
<ul>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/其他" title="view all
posts">其他 (4)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/cpp" title="view all
posts">cpp (2)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/网络" title="view all
posts">网络 (6)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/工具" title="view all
posts">工具 (2)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/linux" title="view all
posts">linux (3)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/python" title="view all
posts">python (1)</a>
</p>

<p style="text-indent:0;margin-top:0.5em">
<a href="/categories/web" title="view all
posts">web (5)</a>
</p>

</ul>

</div>
<div class="site">
	<div class="title">
<a class="extra" href="/">
<font size="6">
Home</font></a> <a class="extra" href="/blog.html"><font size="6">blog</font></a>
<a class="extra" href="/projects.html"><font size="6">projects</font></a>
<a class="extra" href="/about.html"><font size="6">about</font></a>
</div>

	<h1>使用coroutine进行异步编程</h1>
<p class="meta">06 Apr 2015</p>
<div id="post">
<p>在tornado3发布之后，强化了coroutine的概念，在异步编程中，替代了原来的gen.engine，
变成现在的gen.coroutine。这个装饰器本来就是为了简化在tornado中的异步编程。避免写回调函数，
使得开发起来更加符合正常逻辑思维。一个简单的例子如下：</p>




<pre><code>class MaindHandler(web.RequestHandler):
    @asynchronous
    @gen.coroutine
    def post(self):
        client = AsyncHTTPClient()
        resp = yield client.fetch(https://api.github.com/users")
        if resp.code == 200:
            resp = escape.json_decode(resp.body)
            self.write(json.dumps(resp, indent=4, separators=(',', ':')))
        else:
            resp = {"message": "error when fetch something"}
            self.write(json.dumps(resp, indent=4, separators={',', ':')))
        self.finish()}))
</code></pre>




<p>在yield语句之后，ioloop将会注册该事件，等到resp返回之后继续执行。这个过程是异步的。在这里使用json.dumps，而没有使用tornado自带的escape.json_encode，是因为在构建REST风格的API的时候，往往会从浏览器里访问获取JSON格式的数据。使用json.dumps格式化数据之后，在浏览器端显示查看的时候会更加友好。Github
API就是这一风格的使用者。其实escape.json_encode就是对json.dumps的简单包装，我在提pull
request要求包装更多功能的时候，作者的回答escape并不打算提供全部的json功能，使用者可以自己直接使用json模块。</p>




<p><strong>Gen.coroutine原理</strong></p>




<p>要使用tornado的异步特性，必须使用异步的库。否则单个进程阻塞，根本不会达到异步的效果。Tornado的异步库中最常用的就是自带的AsyncHTTPClient，以及在其基础上实现的OpenID登录验证接口。另外更多的异步库可以在<a href="https://github.com/tornadoweb/tornado/wiki/Links">这里</a>找到。包括用的比较多的MongoDB的Driver。</p>




<p>在3.0版本之后，gen.coroutine模块显得比较突出。coroutine装饰器可以让本来靠回调的异步编程看起来像同步编程。其中便是利用了Python中生成器的Send函数。在生成器中，yield关键字往往会与正常函数中的return相比。它可以被当成迭代器，从而使用next()返回yield的结果。但是生成器还有另外一个用法，就是使用send方法。在生成器内部可以将yield的结果赋值给一个变量，而这个值是通过外部的生成器client来send的。举一个例子:</p>




<pre><code>def test_yield():
    print "test yeild"
    says = (yield)
    print says

if __name__ == "__main__":
    client = test_yield()
    client.next()
    client.send("hello world")
</code></pre>




<p>输出结果如下：</p>




<pre><code>test yeild
hello world
</code></pre>




<p>已经在运行的函数会挂起，直到调用它的client使用send方法，原来函数继续运行。而这里的gen.coroutine方法就是异步执行需要的操作，然后等待结果返回之后，再send到原函数，原函数则会继续执行，这样就以同步方式写的代码达到了异步执行的效果。</p>




<p><strong>Tornado异步编程</strong></p>




<p>使用coroutine实现函数分离的异步编程。具体如下：</p>




<pre><code>@gen.coroutine
def post(self):
    client = AsyncHTTPClient()
    resp = yield client.fetch("https://api.github.com/users")
    if resp.code == 200:
        body = escape.json_decode(resp.body)
    else:
        body = {"message": "client fetch error"}
        logger.error("client fetch error %d, %s" % (resp.code, resp.message))
    self.write(escape.json_encode(body))
    self.finish()
</code></pre>




<p>换成函数之后可以变成这样:</p>




<pre><code>@gen.coroutime
def post(self):
    resp = yield GetUser()
    self.write(resp)

@gen.coroutine
def GetUser():
    client = AsyncHTTPClient()
    resp = yield client.fetch("https://api.github.com/users")
    if resp.code == 200:
        resp = escape.json_decode(resp.body)
    else:
        resp = {"message": "fetch client error"}
        logger.error("client fetch error %d, %s" % (resp.code, resp.message))
    raise gen.Return(resp)
</code></pre>




<p>这里，当把异步封装在一个函数中的时候，并不是像普通程序那样使用return关键字进行返回，gen模块提供了一个gen.Return的方法。是通过raise方法实现的。这个也是和它是使用生成器方式实现有关的。</p>




<p><strong>使用coroutine跑定时任务</strong></p>




<p>Tornado中有这么一个方法：</p>




<pre><code>tornado.ioloop.IOLoop.instance().add_timeout()
</code></pre>




<p>该方法是time.sleep的非阻塞版本，它接受一个时间长度和一个函数这两个参数。表示多少时间之后调用该函数。在这里它是基于ioloop的，因此是非阻塞的。该方法在客户端长连接以及回调函数编程中使用的比较多。但是用它来跑一些定时任务却是无奈之举。通常跑定时任务也没必要使用到它。在这里，我主要使用它隔一段时间通过Github API接口去抓取数据。大自使用方法如下：</p>




<ul>
<li><p>装饰器</p>

<pre><code>  def sync_loop_call(delta=60 * 1000):
  ""
  Wait for func down then process add_timeout
  ""
      def wrap_loop(func):
          @wraps(func)
          @gen.coroutine
          def wrap_func(*args, **kwargs):
              options.logger.info("function %r start at %d" %
                                  (func.__name__, int(time.time())))
              try:
                  yield func(*args, **kwargs)
              except Exception, e:
                  options.logger.error("function %r error: %s" %
                                       (func.__name__, e))
              options.logger.info("function %r end at %d" %
                                  (func.__name__, int(time.time())))
              tornado.ioloop.IOLoop.instance().add_timeout(
                  datetime.timedelta(milliseconds=delta),
                  wrap_func)
          return wrap_func
      return wrap_loop"
</code></pre></li>
<li><p>任务函数</p>

<pre><code>  @sync_loop_call(delta=10 * 1000)  
      def worker():   
          """  
          Do something   
          """   
</code></pre></li>
<li><p>添加任务</p>

<pre><code>  if __name__ == "__main__":
      worker()
      app.listen(options.port)
      tornado.ioloop.IOLoop.instance().start()
</code></pre></li>
</ul>




<p>这样做之后，当Web
Application启动之后，定时任务就会随着跑起来，而且因为它是基于事件的，并且异步执行的，所以并不会影响Web服务的正常运行，当然任务不能是阻塞的或计算密集型的。我这里主要是抓取数据，而且用的是Tornado自带的异步抓取方法。</p>




<p>在sync_loop_call装饰器中，我在wrap_func函数上加了@gen.coroutine装饰器，这样就保证只有yeild的函数执行完之后，才会执行add_timeout操作。如果没有@gen.coroutine装饰器。那么不等到yeild返回，就会执行add_timeout了。</p>




<p><strong>总结</strong></p>




<p>Tornado是一个非阻塞的web服务器以及web框架，但是在使用的时候只有使用异步的库才会真正发挥它异步的优势，当然有些时候因为App本身要求并不是很高，如果不是阻塞特别严重的话，也不会有问题。另外使用coroutine模块进行异步编程的时候，当把一个功能封装到一个函数中时，在函数运行中，即使出现错误，如果没有去捕捉的话也不会抛出，这在调试上显得非常困难。</p>


<!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1393946814461884" charset="utf-8"></script>
<!-- JiaThis Button END -->
</div>
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jengchen'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    $(document).ready(function() {
		$('pre').addClass('prettyprint').attr('style', 'overflow:auto');
        prettyPrint();
    });
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

</div>
	<div class="footer">
<div class=contact>
<p>©2014 Email:chenfjm@gmail.com Tel:18520222024 </p>
</div>
<div class="share">
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
<a class="addthis_button_tweet"></a>
<div class="g-plusone" data-size="medium" data-annotation="none" data-href="http:chencheng.sn.cn//"></div>
</div>
<script type="text/javascript">var addthis_config = {"data_track_addressbar":true};</script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-510e74d2791fd39c"></script>

<!-- Google+ Plus One Button, asynchronous code -->
<script type="text/javascript">
(function() {
 var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
 po.src = 'https://apis.google.com/js/plusone.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
 })();
</script>
<!-- End Google+ Plus One Button code -->
</div>
</div>

</body>
</html>

