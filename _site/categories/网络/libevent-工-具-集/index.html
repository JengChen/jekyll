<!DOCTYPE html>
<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   
   
   <title>libevent工具集 - JengChen's WebSite</title>
   

   <meta name="author" content="JengChen" />
   
   <meta name="description" content="JengChen's WebSite libevent工具集" />
   

   
  
   <link rel="icon" href=/images/index.png />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- Google Analytics Code -->
   <script type="text/javascript">

     var _gaq = _gaq || [];
     _gaq.push(['_setAccount', 'UA-38185696-1']);
     _gaq.push(['_trackPageview']);

     (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();

   </script>
   <!-- End Google Analytics Code -->

   <!-- Javascript needed by projects.html -->
   <script src="/javascripts/jquery.js" type="text/javascript" charset="utf-8"></script>
   <script type="text/javascript" src="/javascripts/jquery.github.js"></script>

   <!-- Google+ Plus One Button, asynchronous code -->
   <script type="text/javascript">
   (function() {
	var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
	po.src = 'https://apis.google.com/js/plusone.js';
	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>
<!-- End Google+ Plus One Button code -->
</head>

<body>
<div class="article-author-top">
	<img src="http://chenfjm.github.io/images/index.png" class="bio-photo" alt="JengChen bio photo" width="100" height="100"></a>
<!-- <h4>JengChen</h4> -->
<p></p>
<p style="text-indent:0;margin-top:1.5em;"><a href="mailto:chenfjm@gmail.com" target="_blank"><i class="icon-mail"></i> Email</a></p>
<p style="text-indent:0;"><a href="http://twitter.com/jengchen" target="_blank"><i class="icon-twitter"></i> Twitter</a></p>
<p style="text-indent:0;"><a href="http://facebook.com/chenfjm" target="_blank"><i class="icon-facebook"></i> Facebook</a></p>
<p style="text-indent:0;"><a href="http://google.com//chenfjm" target="_blank"><i class="icon-google-plus"></i> Google+</a></p>
<p style="text-indent:0;"><a href="http://linkedin.com/in/chenfjm" target="_blank"><i class="icon-linkedin"></i> LinkedIn</a></p>
<p style="text-indent:0;"><a href="http://instagram.com/chenfjm" target="_blank"><i class="icon-instagram"></i> Instagram</a></p>
<p style="text-indent:0;"><a href="http://github.com/chenfjm" target="_blank"><i class="icon-github"></i> Github</a></p>



</div>
<div class="site">
	<div class="title">
<a href=https://github.com/chenfjm>
<img src=images/octocat-icon.png>
</a>
<a class="extra" href="/">
<font size="6">
Home</font></a> <a class="extra" href="/blog.html"><font size="6">blog</font></a>
<a class="extra" href="/projects.html"><font size="6">projects</font></a>
<a class="extra" href="/about.html"><font size="6">about</font></a>
</div>

	<h1>libevent工具集</h1>
<p class="meta">27 Sep 2013</p>
<div class="social">
  <div class="share">
    <div class="g-plusone" data-size="medium"></div>
  </div>
  <div class="share">
    <iframe allowtransparency="true" frameborder="0" scrolling="no" src="http://platform.twitter.com/widgets/tweet_button.html?url=http://chenfjm.github.io/categories/%E7%BD%91%E7%BB%9C/libevent-%E5%B7%A5-%E5%85%B7-%E9%9B%86&text=libevent工具集&hashtags=&via=JengChen&count=horizontal" style="width:115px; height:21px;"></iframe>
  </div>
</div>
<br />
<br />
<div id="post">
<p><strong>基本类型</strong></p>

<p>evutil_socket_t</p>

<p>在除Windows之外的大多数地方，套接字是个整数，操作系统按照数值次序进行处理。然而，使用Windows套接字API时，socket具有类型SOCKET，它实际上是个类似指针的句柄，收到这个句柄的次序是未定义的。在Windows中，libevent定义evutil_socket_t类型为整型指针，可以处理socket()或者accept()的输出，而没有指针截断的风险。</p>

<pre><code>#ifdef WIN32
#define evutil_socket_t intptr_t
#else
#define evutil_socket_t int
#endif  
</code></pre>

<p>标准整数类型</p>

<pre><code>ev_uint64_t
ev_int64_t
ev_uint32_t
ev_int32_t
ev_uint16_t
ev_int16_t
ev_uint8_t
ev_int8_t  
</code></pre>

<p>各种兼容性类型</p>

<pre><code>ev_uintptr_t
ev_intptr_t
ev_ssize_t
ev_off_t  
</code></pre>

<p><strong>定时器可移植函数</strong></p>

<p>不是每个平台都定义了标准timeval操作函数，所以libevent也提供了自己的实现</p>

<pre><code>#define evutil_timeradd(tvp, uvp, vvp) /* ... */
#define evutil_timersub(tvp, uvp, vvp) /* ... */  
</code></pre>

<p>这些宏分别对前两个参数进行加或者减运算，将结果存放到第三个参数中。</p>

<pre><code>#define evutil_timerclear(tvp) /* ... */
#define evutil_timerisset(tvp) /* ... */  
</code></pre>

<p>清除timeval会将其值设置为0。evutil_timerisset宏检查timeval是否已经设置，如果已经设置为非零值，返回ture，否则返回false。</p>

<pre><code>#define evutil_timercmp(tvp, uvp, cmp)  
</code></pre>

<p>evutil_timercmp宏比较两个timeval，如果其关系满足cmp关系运算符，返回true。</p>

<pre><code>int evutil_gettimeofday(struct timeval *tv, struct timezone *tz);  
</code></pre>

<p>evutil_gettimeofdy（）函数设置tv为当前时间，tz参数未使用。</p>

<p><strong>套接字API兼容性</strong></p>

<pre><code>int evutil_closesocket(evutil_socket_t s);
#define EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)  
</code></pre>

<p>这个接口用于关闭套接字。在Unix中，它是close()的别名；在Windows中，它调用closesocket()。</p>

<pre><code>#define EVUTIL_SOCKET_ERROR()
#define EVUTIL_SET_SOCKET_ERROR(errcode)
#define evutil_socket_geterror(sock)
#define evutil_socket_error_to_string(errcode)  
</code></pre>

<p>这些宏访问和操作套接字错误代码。EVUTIL_SOCKET_ERROR（）返回本线程最后一次套接字操作的全局错误号，evutil_socket_geterror（）则返回某特定套接字的错误号。（在类Unix系统中都是errno）EVUTIL_SET_SOCKET_ERROR()修改当前套接字错误号（与设置Unix中的errno类似），evutil_socket_error_to_string（）返回代表某给定套接字错误号的字符串（与Unix中的strerror()类似）。</p>

<pre><code>int evutil_make_socket_nonblocking(evutil_socket_t sock);  
</code></pre>

<p>用于对套接字进行非阻塞IO的调用也不能移植到Windows中。evutil_make_socket_nonblocking()函数要求一个套接字（来自socket()或者accept()）作为参数，将其设置为非阻塞的。（设置Unix中的O_NONBLOCK标志和Windows中的FIONBIO标志）</p>

<pre><code>int evutil_make_listen_socket_reuseable(evutil_socket_t sock);  
</code></pre>

<p>这个函数确保关闭监听套接字后，它使用的地址可以立即被另一个套接字使用。（在Unix中它设置SO_REUSEADDR标志，在Windows中则不做任何操作。不能在Windows中使用SO_REUSEADDR标志：它有另外不同的含义。</p>

<pre><code>int evutil_make_socket_closeonexec(evutil_socket_t sock);  
</code></pre>

<p>这个函数告诉操作系统，如果调用了exec()，应该关闭指定的套接字。在Unix中函数设置FD_CLOEXEC标志，在Windows上则没有操作。</p>

<pre><code>int evutil_socketpair(int family, int type, int protocol,evutil_socket_t sv[2]);  
</code></pre>

<p>这个函数的行为跟Unix的socketpair（）调用相同：创建两个相互连接起来的套接字，可对其使用普通套接字IO调用。函数将两个套接字存储在sv[0]和sv[1]中，成功时返回0，失败时返回-1。 在Windows中，这个函数仅能支持AF_INET协议族、SOCK_STREAM类型和0协议的套接字。注意：在防火墙软件明确阻止127.0.0.1，禁止主机与自身通话的情况下，函数可能失败。</p>

<p><strong>可移植的字符串操作函数</strong></p>

<pre><code>ev_int64_t evutil_strtoll(const char *s, char **endptr, int base);  
</code></pre>

<p>这个函数与strtol行为相同，只是用于64位整数。在某些平台上，仅支持十进制。</p>

<pre><code>int evutil_snprintf(char *buf, size_t buflen, const char *format, ...);
int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap);  
</code></pre>

<p>这些snprintf替代函数的行为与标准snprintf和vsnprintf接口相同。函数返回在缓冲区足够长的情况下将写入的字节数，不包括结尾的NULL字节。（这个行为遵循C99的snprintf()标准，但与Windows的<em>snprintf()相反：如果字符串无法放入缓冲区，</em>snprintf()会返回负数）</p>

<p><strong>区域无关的字符串操作函数</strong></p>

<p>实现基于ASCII的协议时，可能想要根据字符类型的ASCII记号来操作字符串，而不管当前的区域设置。libevent为此提供了一些函数：</p>

<pre><code>int evutil_ascii_strcasecmp(const char *str1, const char *str2);
int evutil_ascii_strncasecmp(const char *str1, const char *str2, size_t n);  
</code></pre>

<p>这些函数与strcasecmp()和strncasecmp()的行为类似，只是它们总是使用ASCII字符集进行比较，而不管当前的区域设置。</p>

<p><strong>IPv6辅助和兼容性函数</strong></p>

<pre><code>const char *evutil_inet_ntop(int af, const void *src, char *dst, size_t len);
int evutil_inet_pton(int af, const char *src, void *dst);  
</code></pre>

<p>这些函数根据RFC3493的规定解析和格式化IPv4与IPv6地址，与标准inet_ntop()和inet_pton()函数行为相同。要格式化IPv4地址，调用evutil_inet_ntop()，设置af为AF_INET，src指向in_addr结构体，dst指向大小为len的字符缓冲区。对于IPv6地址，af应该是AF_INET6，src则指向in6_addr结构体。要解析IP地址，调用evutil_inet_pton()，设置af为AF_INET或者AF_INET6，src指向要解析的字符串，dst指向一个in_addr或者in_addr6结构体。 失败时evutil_inet_ntop()返回NULL，成功时返回到dst的指针。成功时evutil_inet_pton()返回0，失败时返回-1。</p>

<pre><code>int evutil_parse_sockaddr_port(const char *str, struct sockaddr *out,int *outlen);  
</code></pre>

<p>这个接口解析来自str的地址，将结果写入到out中。outlen参数应该指向一个表示out中可用字节数的整数；函数返回时这个整数将表示实际使用了的字节数。成功时函数返回0，失败时返回-1。</p>

<pre><code>int evutil_sockaddr_cmp(const struct sockaddr *sa1,const struct sockaddr *sa2, int include_port);  
</code></pre>

<p>evutil_sockaddr_cmp()函数比较两个地址，如果sa1在sa2前面，返回负数；如果二者相等，则返回0；如果sa2在sa1前面，则返回正数。函数可用于AF_INET和AF_INET6地址；对于其他地址，返回值未定义。函数确保考虑地址的完整次序，但是不同版本中的次序可能不同。 如果include_port参数为false，而两个地址只有端口号不同，则它们被认为是相等的。否则，具有不同端口号的地址被认为是不等的。</p>

<p><strong>结构体可移植性函数</strong></p>

<pre><code>#define evutil_offsetof(type, field) /* ... */  
</code></pre>

<p>跟标准offsetof宏一样，这个宏返回从type类型开始处到field字段的字节数。</p>

<p><strong>安全随机数发生器</strong></p>

<pre><code>void evutil_secure_rng_get_bytes(void *buf, size_t n);  
</code></pre>

<p>这个函数用随机数据填充buf处的n个字节。 如果所在平台提供了arc4random()，libevent会使用这个函数。否则，libevent会使用自己的arc4random()实现，种子则来自操作系统的熵池（entropypool）（Windows中的CryptGenRandom，其他平台中的/dev/urandom）</p>

<pre><code>int evutil_secure_rng_init(void);
void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);  
</code></pre>

<p>不需要手动初始化安全随机数发生器，但是如果要确认已经成功初始化，可以调用evutil_secure_rng_init()。函数会播种RNG（如果没有播种过），并在成功时返回0。函数返回-1则表示libevent无法在操作系统中找到合适的熵源（sourceofentropy），如果不自己初始化RNG，就无法安全使用RNG了。</p>

</div>
  <wb:share-button type="button" size="middle" relateuid="2418291384" ></wb:share-button>
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jengchen'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

</div>
	  <div class="footer">
        <div class="rss">
        <p>
        <!-- AddThis Button BEGIN -->
         <div class="addthis_toolbox addthis_default_style ">
         <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
         <a class="addthis_button_tweet"></a>
         <div class="g-plusone" data-size="medium" data-annotation="none" data-href="http:chencheng.sn.cn//"></div>
         </div>
         <script type="text/javascript">var addthis_config = {"data_track_addressbar":true};</script>
         <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-510e74d2791fd39c"></script>
         </p>
         </div>
  </div>

</body>
</html>

